# 数据完整性判断逻辑改进

## 改进前

### 判断标准
```python
# 简单按 365 天中的 250 个交易日估算
expected_days = int(((end_dt - start_dt).days * 250 / 365) * 0.95)
```

### 问题
1. **未考虑实际交易日**：使用固定比例（250/365）估算，忽略了：
   - 周末和法定节假日
   - 调休工作日
2. **未考虑停牌**：股票停牌期间无交易数据，但被计入预期天数
3. **误判率高**：新股、长期停牌股票容易被误判为"不完整"

## 改进后

### 判断标准

```python
预期交易日 = 交易所交易日历 - 股票停牌日
完整度阈值 = 预期交易日 × 95%
```

### 逻辑流程

```
1. 获取交易所（SSE/SZSE/BJSE）
   ↓
2. 获取交易日历（去掉周末、节假日）
   ↓
3. 获取停牌日期（需要 Tushare 积分）
   ↓
4. 计算：预期交易日 = 交易日 - 停牌日
   ↓
5. 容错：expected_days = 预期交易日 × 0.95
```

### 代码实现

```python
def _calc_expected_trading_days(self, ts_code: str, start_date: str, end_date: str) -> int:
    """计算预期交易日天数（考虑实际交易日和股票停牌）"""
    exchange = self._get_exchange(ts_code)
    
    # 1. 获取交易日历
    trade_cal = self.get_trade_cal(exchange, start_date, end_date)
    total_trading_days = len(trade_cal)
    
    # 2. 获取停牌日期
    suspend_df = self.pro.suspend_cal(ts_code=ts_code, start_date=start_date, end_date=end_date)
    suspend_days = len(suspend_df)
    
    # 3. 计算预期交易日
    expected_days = max(0, total_trading_days - suspend_days)
    
    # 4. 容错处理（5% 误差）
    return int(expected_days * 0.95)
```

## 示例对比

### 场景 1：正常股票（2023 年全年）

| 项目 | 改进前 | 改进后 |
|------|--------|--------|
| 日期范围 | 365 天 | 365 天 |
| 估算方法 | 365 × 250/365 × 0.95 | 实际交易日 242 天 × 0.95 |
| 预期天数 | 237 天 | 230 天 |
| 实际数据 | 242 天 | 242 天 |
| 完整度 | 102% ✅ | 105% ✅ |
| 判断结果 | 完整 | 完整 |

### 场景 2：长期停牌股票（停牌 30 天）

| 项目 | 改进前 | 改进后 |
|------|--------|--------|
| 日期范围 | 365 天 | 365 天 |
| 估算方法 | 365 × 250/365 × 0.95 | (242 - 30) × 0.95 |
| 预期天数 | 237 天 | 201 天 |
| 实际数据 | 212 天 | 212 天 |
| 完整度 | 89% ❌ 不完整 | 105% ✅ 完整 |
| 判断结果 | 不完整（误判） | 完整（正确） |

### 场景 3：新股（上市 100 天）

| 项目 | 改进前 | 改进后 |
|------|--------|--------|
| 日期范围 | 365 天 | 365 天 |
| 估算方法 | 365 × 250/365 × 0.95 | 实际交易日 × 0.95 |
| 预期天数 | 237 天 | 230 天 |
| 实际数据 | 100 天 | 100 天 |
| 完整度 | 42% ❌ | 43% ❌ |
| 判断结果 | 不完整 | 不完整 |

**说明：** 新股两种方法都会判断为不完整，这是正确的。

## 完整性阈值

| 完整度 | 判断 | 操作 |
|--------|------|------|
| **≥ 95%** | 完整数据 | 标记 `is_complete=True`，后续直接返回 |
| **90% - 95%** | 基本完整 | 自动标记为完整 |
| **< 90%** | 不完整 | 返回 None，触发重新获取 |

## 数据依赖

### Tushare 接口

1. **trade_cal** - 交易日历
   - 权限：基础权限（免费）
   - 用途：获取交易所交易日

2. **suspend_cal** - 停牌日历
   - 权限：需要积分
   - 用途：获取股票停牌日期
   - 降级：无法获取时使用交易日总数

### 缓存优化

- 交易日历会缓存，避免重复调用 API
- 停牌数据不缓存（调用频率低）

## 使用影响

### 正面影响

1. **减少误判**：长期停牌股票不会被误判为不完整
2. **准确增量更新**：只更新真正缺失的数据
3. **节省时间**：避免重复获取已完整的数据

### 注意事项

1. **停牌数据权限**：如果没有 suspend_cal 权限，会退化为只使用交易日历
2. **新股判断**：新股仍然会被判断为不完整，需要等待上市时间足够长

## 测试验证

```bash
# 运行测试脚本
python -m quant_strategy.tools.test_trading_days
```

输出示例：
```
======================================================================
测试交易日计算逻辑
======================================================================
日期范围：20230101 - 20231231

600519.SH (贵州茅台):
  交易所：SSE
  预期交易日：230 天
  实际数据：242 天
  完整度：105.2%
  状态：[完整]

000001.SZ (平安银行):
  交易所：SZSE
  预期交易日：230 天
  实际数据：241 天
  完整度：104.8%
  状态：[完整]
```

## 相关文件

- `quant_strategy/data/tushare_provider.py` - 核心实现
- `quant_strategy/data/data_cache.py` - 缓存完整性检查
- `quant_strategy/tools/fetch_all_stocks.py` - 批量获取工具
- `quant_strategy/tools/verify_cache.py` - 缓存验证工具
